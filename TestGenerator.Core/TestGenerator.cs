using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TestGenerator.Core;

public class TestGenerator
{
    public class TestInfo
    {
        public string ClassName;
        public string GeneratedCode = "";
    }

    private List<TestInfo> _testInfo;

    public TestGenerator()
    {
        _testInfo = new List<TestInfo>();
    }

    public List<TestInfo> Generate(string programText)
    {
        SyntaxTree tree = CSharpSyntaxTree.ParseText(programText);
        CompilationUnitSyntax root = tree.GetCompilationUnitRoot();

        var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
        var methods = root.DescendantNodes().OfType<MethodDeclarationSyntax>().ToList();

        // create namespace
        MemberDeclarationSyntax? @namespace = null;
        var mainUnit = CompilationUnit();
        foreach (var _class in classes)
        {
            //add namespace
            @namespace = NamespaceDeclaration(IdentifierName(GetNamespace(_class) + ".Test"));
            
            var usings = new SyntaxList<UsingDirectiveSyntax>(
                new UsingDirectiveSyntax[]
                {
                    UsingDirective(
                        IdentifierName(GetNamespace(_class))),
                    UsingDirective(
                        QualifiedName(
                            IdentifierName("NUnit"),
                            IdentifierName("Framework")))
                });

            mainUnit = mainUnit.WithUsings(usings);
            
            var test = Attribute(IdentifierName("Test"));
            
            // add class
            var classDeclaration = ClassDeclaration(_class.Identifier + "Tests")
                .AddModifiers(Token(SyntaxKind.PublicKeyword)).AddAttributeLists(
                    AttributeList(
                        SingletonSeparatedList<AttributeSyntax>(
                            Attribute(
                                IdentifierName("TestFixture")))));
            
            // get interfaces
            var constructors = _class.DescendantNodes().OfType<ConstructorDeclarationSyntax>();
            IEnumerable<ParameterSyntax> interfaces = null;
            foreach (var constructor in constructors)
            {
                interfaces = constructor.ParameterList.Parameters.Where(t =>
                {
                    return t.Identifier.ToString().StartsWith("I");
                });
            }

            if (interfaces != null)
                AddFields(@_class);
            // add fields
            
            
            // add setup
            
            
            List<MethodDeclarationSyntax> methodDeclaration = new List<MethodDeclarationSyntax>();
            var syntax = ParseStatement("Assert.Fail(\"autogenerated\");");
            foreach (var method in methods)
            {
                var parentClass = method.Parent;
                string text = "";
                if (parentClass is ClassDeclarationSyntax methodClass)
                    text = methodClass.Identifier.ToString();

                if (text == _class.Identifier.ToString())
                {
                    // add method
                    methodDeclaration.Add(MethodDeclaration(ParseTypeName("void"), method.Identifier + "Test")
                        .AddModifiers(Token(SyntaxKind.PublicKeyword))
                        .AddAttributeLists(
                            AttributeList(
                                SingletonSeparatedList<AttributeSyntax>(
                                    Attribute(
                                        IdentifierName("Test")))))
                        .WithBody(Block(syntax)));
                }
            }

            classDeclaration = classDeclaration.AddMembers(methodDeclaration.ToArray());
            @namespace = ((NamespaceDeclarationSyntax)@namespace).AddMembers(classDeclaration);

            mainUnit = mainUnit.WithMembers(SingletonList<MemberDeclarationSyntax>(@namespace)).NormalizeWhitespace();
            _testInfo.Add(new TestInfo
            {
                ClassName = _class.Identifier + "Tests",
                GeneratedCode = mainUnit.NormalizeWhitespace().ToFullString()
            });
        }
        return _testInfo;
    }

    /*private MyClass _myClassUnderTest;
    private Mock<IDependency> _dependency;*/
    
    private void AddFields(ClassDeclarationSyntax @class)
    {
        var variableDeclaration = SyntaxFactory.VariableDeclaration(SyntaxFactory.ParseTypeName("bool"))
            .AddVariables(SyntaxFactory.VariableDeclarator("canceled"));
        var fieldDeclaration = SyntaxFactory.FieldDeclaration(variableDeclaration)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword));
    }

    private string GetNamespace(ClassDeclarationSyntax @class)
    {
        string nameSpace = string.Empty;
        SyntaxNode? potentialNamespaceParent = @class.Parent;
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }
        
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();
        
            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }
        return nameSpace;
    }
}